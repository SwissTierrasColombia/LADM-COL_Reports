<?xml version="1.0" encoding="UTF-8"?>
<!-- Created with Jaspersoft Studio version 6.6.0.final using JasperReports Library version 6.6.0  -->
<jasperReport xmlns="http://jasperreports.sourceforge.net/jasperreports" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://jasperreports.sourceforge.net/jasperreports http://jasperreports.sourceforge.net/xsd/jasperreport.xsd" name="sub_report_boundaries" pageWidth="595" pageHeight="842" columnWidth="595" leftMargin="0" rightMargin="0" topMargin="0" bottomMargin="20" uuid="8044c259-bf6b-4072-8923-78bca3eb0308">
	<property name="com.jaspersoft.studio.data.sql.tables" value=""/>
	<property name="com.jaspersoft.studio.data.defaultdataadapter" value="New Data Adapter "/>
	<property name="com.jaspersoft.studio.unit." value="pixel"/>
	<property name="com.jaspersoft.studio.unit.pageHeight" value="pixel"/>
	<property name="com.jaspersoft.studio.unit.pageWidth" value="pixel"/>
	<property name="com.jaspersoft.studio.unit.topMargin" value="pixel"/>
	<property name="com.jaspersoft.studio.unit.bottomMargin" value="pixel"/>
	<property name="com.jaspersoft.studio.unit.leftMargin" value="pixel"/>
	<property name="com.jaspersoft.studio.unit.rightMargin" value="pixel"/>
	<property name="com.jaspersoft.studio.unit.columnWidth" value="pixel"/>
	<property name="com.jaspersoft.studio.unit.columnSpacing" value="pixel"/>
	<property name="com.jaspersoft.studio.property.dataset.dialog.DatasetDialog.sash.w1" value="779"/>
	<property name="com.jaspersoft.studio.property.dataset.dialog.DatasetDialog.sash.w2" value="212"/>
	<property name="com.jaspersoft.studio.data.sql.SQLQueryDesigner.sash.w1" value="220"/>
	<property name="com.jaspersoft.studio.data.sql.SQLQueryDesigner.sash.w2" value="774"/>
	<parameter name="id" class="java.lang.Integer">
		<defaultValueExpression><![CDATA[66040]]></defaultValueExpression>
	</parameter>
	<parameter name="criterio_punto_inicial" class="java.lang.Integer"/>
	<parameter name="datasetName" class="java.lang.String"/>
	<queryString language="SQL">
		<![CDATA[WITH 
parametros AS (
  SELECT
     $P{id}  AS poligono_t_id, 
      1 	AS criterio_punto_inicial, --tipo de criterio para seleccionar el punto inicial del terreno, valores posibles: 1,2
    4		AS criterio_observador, --1: Centroide, 2: Centro del extent, 3: punto en la superficie, 4: Punto mas cercano al centroide dentro del poligono 
    false	AS incluir_tipo_derecho, --Mostrar el tipo de derecho de cada interesado (booleano)
    15		as tolerancia_sentidos --tolerancia en grados para la definicion del sentido de una linea
),
t AS ( --Orienta los vertices del terreno en sentido horario
	SELECT t_id, ST_ForceRHR(poligono_creado) as poligono_creado FROM $P!{datasetName}.terreno AS t, parametros WHERE t.t_id = poligono_t_id 
),
--bordes de la extension del poligono
a AS (
	SELECT ST_SetSRID(ST_MakePoint(st_xmin(t.poligono_creado), st_ymax(t.poligono_creado)), ST_SRID(t.poligono_creado)) AS p FROM t
),
b AS (
	SELECT ST_SetSRID(ST_MakePoint(st_xmax(t.poligono_creado), st_ymax(t.poligono_creado)), ST_SRID(t.poligono_creado)) AS p FROM t
),
c AS (
	SELECT ST_SetSRID(ST_MakePoint(st_xmax(t.poligono_creado), st_ymin(t.poligono_creado)), ST_SRID(t.poligono_creado)) AS p FROM t
),
d AS (
	SELECT ST_SetSRID(ST_MakePoint(st_xmin(t.poligono_creado), st_ymin(t.poligono_creado)), ST_SRID(t.poligono_creado)) AS p FROM t
),
--Punto medio (ubicaci�n del observador para la definicion de las cardinalidades)
m AS (
  SELECT
    CASE WHEN criterio_observador = 1 THEN --centroide del poligono
      ( SELECT ST_SetSRID(ST_MakePoint(st_x(ST_centroid(t.poligono_creado)), st_y(ST_centroid(t.poligono_creado))), ST_SRID(t.poligono_creado)) AS p FROM t )
    WHEN criterio_observador = 2 THEN --Centro del extent
      ( SELECT ST_SetSRID(ST_MakePoint(st_x(ST_centroid(st_envelope(t.poligono_creado))), st_y(ST_centroid(st_envelope(t.poligono_creado)))), ST_SRID(t.poligono_creado)) AS p FROM t )
    WHEN criterio_observador = 3 THEN --Punto en la superficie
      ( SELECT ST_SetSRID(ST_PointOnSurface(poligono_creado), ST_SRID(t.poligono_creado)) AS p FROM t )
    WHEN criterio_observador = 4 THEN --Punto mas cercano al centroide pero que se intersecte el poligono si esta fuera
      ( SELECT ST_SetSRID(ST_MakePoint(st_x( ST_ClosestPoint( poligono_creado, ST_centroid(t.poligono_creado))), st_y( ST_ClosestPoint( poligono_creado,ST_centroid(t.poligono_creado)))), ST_SRID(t.poligono_creado)) AS p FROM t )
    ELSE --defecto: Centro del extent
      ( SELECT ST_SetSRID(ST_MakePoint(st_x(ST_centroid(st_envelope(t.poligono_creado))), st_y(ST_centroid(st_envelope(t.poligono_creado)))), ST_SRID(t.poligono_creado)) AS p FROM t )
    END as p
    FROM parametros
),
--Cuadrantes del pol�gono desde el observador a cada una de las esquinas de la extensi�n del pol�gono
norte AS (
	SELECT ST_SetSRID(ST_MakePolygon(ST_MakeLine(ARRAY [a.p, b.p, m.p, a.p])), ST_SRID(t.poligono_creado)) geom FROM t,a,b,m
),
este AS (
	SELECT ST_SetSRID(ST_MakePolygon(ST_MakeLine(ARRAY [m.p, b.p, c.p, m.p])), ST_SRID(t.poligono_creado)) geom FROM t,b,c,m
),
sur AS (
	SELECT ST_SetSRID(ST_MakePolygon(ST_MakeLine(ARRAY [m.p, c.p, d.p, m.p])), ST_SRID(t.poligono_creado)) geom FROM t,m,c,d
),
oeste AS (
	SELECT ST_SetSRID(ST_MakePolygon(ST_MakeLine(ARRAY [a.p, m.p, d.p, a.p])), ST_SRID(t.poligono_creado)) geom FROM t,a,m,d
)
,limite_poligono as(
	SELECT t_id, ST_Boundary(poligono_creado) geom FROM t
)
,limite_vecinos as (  --obtiene el limite de los terrenos colindantes, filtrados por bounding box
	select o.t_id, ST_Boundary(o.poligono_creado) geom from t, $P!{datasetName}.terreno o where o.poligono_creado && st_envelope(t.poligono_creado) and t.t_id <> o.t_id 
)
,pre_colindancias as ( --inteseccion entre el limite del poligono y los terrenos cercanos, a�ade la geometria de los limites sin adjacencia
	SELECT limite_vecinos.t_id, st_intersection(limite_poligono.geom,limite_vecinos.geom) geom  FROM limite_poligono,limite_vecinos where st_intersects(limite_poligono.geom,limite_vecinos.geom) and limite_poligono.t_id <> limite_vecinos.t_id
	union 
	SELECT null as t_id, ST_Difference(limite_poligono.geom, a.geom) geom
	FROM limite_poligono,
	(
		select ST_LineMerge(ST_Union(geom)) geom from limite_vecinos
	) a 
)
, tmp_colindantes as (
	select  t_id,ST_LineMerge(ST_Union(geom)) geom from 
	(
		SELECT
		  simple.t_id,
		  simple.simple_geom as geom,
		  ST_GeometryType(simple.simple_geom) as geom_type,
		  ST_AsEWKT(simple.simple_geom) as geom_wkt
		FROM (
		  SELECT
		    dumped.*,
		    (dumped.geom_dump).geom as simple_geom,
		    (dumped.geom_dump).path as path
		  FROM (
		    SELECT *, ST_Dump(geom) AS geom_dump FROM pre_colindancias
		  ) as dumped
		) AS simple
	) a
	group by t_id
)
, lineas_colindancia as ( --contiene las lineas de cambio de colindancia todas las lineas son parte simple
	SELECT * FROM
	(
		SELECT
		  simple.t_id,
		  simple.simple_geom as geom
		FROM (
		  SELECT
		    dumped.*,
		    (dumped.geom_dump).geom as simple_geom,
		    (dumped.geom_dump).path as path
		  FROM (
		    SELECT *, ST_Dump(geom) AS geom_dump FROM (select * from tmp_colindantes where ST_GeometryType(geom) = 'ST_MultiLineString') a
		  ) as dumped
		) AS simple			
	) a 
	UNION 
	select * from tmp_colindantes where ST_GeometryType(geom) <> 'ST_MultiLineString'
)
, puntos_terreno as (
	SELECT (ST_DumpPoints(poligono_creado)).* AS dp
	FROM t
)
--Criterio 1: el punto inicial del terreno es el primer punto del lindero que intersecte con el punto ubicado mas cerca de la esquina nw del pol�gono
, punto_nw as (
	SELECT 	geom
		,st_distance(geom, nw) AS dist
	FROM 	puntos_terreno,
		(SELECT ST_SetSRID(ST_MakePoint(st_xmin(st_envelope(poligono_creado)), st_ymax(st_envelope(poligono_creado))), ST_SRID(poligono_creado)) as nw FROM t ) a
	ORDER BY dist limit 1
)
, punto_inicial_por_lindero_con_punto_nw as (
	select st_startpoint(lineas_colindancia.geom) geom from lineas_colindancia, punto_nw where st_intersects(lineas_colindancia.geom, punto_nw.geom ) and not st_intersects(st_endpoint(lineas_colindancia.geom), punto_nw.geom )  limit 1
)
--Criterio 2: el punto inicial del terreno es el primer punto del lindero que tenga mayor porcentaje de su longitud sobre el cuadrante norte del poligono
, punto_inicial_por_lindero_porcentaje_n as(
	select 	round((st_length(st_intersection(lineas_colindancia.geom, norte.geom))/st_length(lineas_colindancia.geom))::numeric,2) dist, 
		st_startpoint(lineas_colindancia.geom) geom 
		,st_distance(lineas_colindancia.geom,nw) distance_to_nw
		from lineas_colindancia
			,norte
			,(SELECT ST_SetSRID(ST_MakePoint(st_xmin(st_envelope(poligono_creado)), st_ymax(st_envelope(poligono_creado))), ST_SRID(poligono_creado)) as nw FROM t ) a
		where st_intersects(lineas_colindancia.geom, norte.geom)  order by dist desc, distance_to_nw
		limit 1
)
--Criterio para definir el punto inicial del terreno
,punto_inicial as (
	SELECT 
		CASE WHEN criterio_punto_inicial = 1 THEN (select geom from punto_inicial_por_lindero_con_punto_nw)
		WHEN criterio_punto_inicial = 2 THEN (select geom from punto_inicial_por_lindero_porcentaje_n)
	END as geom
	FROM parametros
)
, puntos_ordenados as (
	SELECT case when id-m+1 <= 0 then total + id-m else id-m+1 end as id, geom , st_x(geom) x, st_y(geom) y FROM
		(
		SELECT row_number() OVER (ORDER BY path) AS id
			,m
			,path
			,geom
			,total
		FROM (
			SELECT (ST_DumpPoints(ST_ForceRHR(poligono_creado))).* AS dp
				,ST_NPoints(poligono_creado) total
				,poligono_creado
			FROM t
			) AS a
			,(
				SELECT row_number() OVER (ORDER BY path) AS m
					,st_distance(puntos_terreno.geom, punto_inicial.geom) AS dist
				FROM puntos_terreno,punto_inicial
				ORDER BY dist limit 1
			) b
		) t
		where id <> total
	order by id
)
, cuadrantes as (
	SELECT '1_Norte' ubicacion,norte.geom as cuadrante FROM norte 
	UNION
	SELECT '2_Este' ubicacion,este.geom as cuadrante FROM este 
	UNION
	SELECT '3_Sur' ubicacion,sur.geom as cuadrante FROM sur 
	UNION
	SELECT '4_Oeste' ubicacion,oeste.geom as cuadrante FROM oeste
)
, lineas_colindancia_desde_hasta as (
	select *
		,(SELECT id from puntos_ordenados WHERE st_intersects(puntos_ordenados.geom, st_startpoint(lineas_colindancia.geom))) desde
		,(SELECT id from puntos_ordenados WHERE st_intersects(puntos_ordenados.geom, st_endpoint(lineas_colindancia.geom))) hasta
	from lineas_colindancia
	order by desde
)
, colindantes as (
	SELECT row_number() OVER (ORDER BY desde) AS id, t_id,desde,hasta,ubicacion,geom FROM
	(
		select * 
			,st_length(st_intersection(geom,cuadrante))/st_length(geom) as porcentaje 
			,max(st_length(st_intersection(geom,cuadrante))/st_length(geom)) over (partition by geom) as max_porce
		from lineas_colindancia_desde_hasta, cuadrantes where st_intersects(geom,cuadrante)
	) a
	where porcentaje = max_porce
),
predios_seleccionados as (
	select baunit_predio as t_id_predio, colindantes.t_id as t_id_colindante from colindantes
	left join $P!{datasetName}.uebaunit ON colindantes.t_id = ue_terreno 
),
derechos_seleccionados AS (
	 SELECT DISTINCT col_derecho.t_id as t_id_derecho, predios_seleccionados.t_id_colindante  
	 FROM predios_seleccionados LEFT JOIN $P!{datasetName}.col_derecho 
	 ON col_derecho.unidad_predio = predios_seleccionados.t_id_predio
 ),
 derecho_interesados AS (
	 SELECT DISTINCT col_derecho.interesado_col_interesado, col_derecho.t_id as t_id_derecho, derechos_seleccionados.t_id_colindante  
	 FROM derechos_seleccionados LEFT JOIN $P!{datasetName}.col_derecho 
	 ON col_derecho.t_id = derechos_seleccionados.t_id_derecho WHERE col_derecho.interesado_col_interesado IS NOT NULL
 ),
 derecho_agrupacion_interesados AS (
	 SELECT DISTINCT col_derecho.interesado_la_agrupacion_interesados, miembros.interesados_col_interesado, derechos_seleccionados.t_id_colindante, miembros.agrupacion 
	 FROM derechos_seleccionados LEFT JOIN $P!{datasetName}.col_derecho 
	 ON col_derecho.t_id = derechos_seleccionados.t_id_derecho
	 LEFT JOIN $P!{datasetName}.miembros 
	 ON col_derecho.interesado_la_agrupacion_interesados = miembros.agrupacion
	 WHERE col_derecho.interesado_la_agrupacion_interesados IS NOT NULL
 ),
 info_agrupacion_filter as (
		select distinct on (agrupacion) agrupacion
		,col_interesado.p_local_id as local_id
		,(case when col_interesado.t_id is not null then 'agrupacion' end) as agrupacion_interesado
	 	,(coalesce(col_interesado.primer_nombre,'') || coalesce(' ' || col_interesado.segundo_nombre, '') || coalesce(' ' || col_interesado.primer_apellido, '') || coalesce(' ' || col_interesado.segundo_apellido, '')  
				|| coalesce(col_interesado.razon_social, '') ) as nombre
		,t_id_colindante
		from derecho_agrupacion_interesados LEFT JOIN $P!{datasetName}.col_interesado ON col_interesado.t_id = derecho_agrupacion_interesados.interesados_col_interesado order by agrupacion
 ),
 info_interesado as (
		select
	 	col_interesado.p_local_id as local_id
	 	,(case when col_interesado.t_id is not null then 'interesado' end) as agrupacion_interesado
	 	,(coalesce(col_interesado.primer_nombre,'') || coalesce(' ' || col_interesado.segundo_nombre, '') || coalesce(' ' || col_interesado.primer_apellido, '') || coalesce(' ' || col_interesado.segundo_apellido, '')  
				|| coalesce(col_interesado.razon_social, '') ) as nombre
		,t_id_colindante
 		from derecho_interesados LEFT JOIN $P!{datasetName}.col_interesado ON col_interesado.t_id = derecho_interesados.interesado_col_interesado
 ),
 info_agrupacion as (
		select local_id
		,agrupacion_interesado
		,nombre
		,t_id_colindante
		from info_agrupacion_filter
),
 info_total_interesados as (select * from info_interesado union all select * from info_agrupacion)
 select 
   id
  ,desde
  ,hasta
  ,ubicacion
  ,round(st_x(st_startpoint(colindantes.geom))::numeric,2) xi
  ,round(st_y(st_startpoint(colindantes.geom))::numeric,2) yi
  ,round(st_x(st_endpoint(colindantes.geom))::numeric,2) xf
  ,round(st_y(st_endpoint(colindantes.geom))::numeric,2) yf
  ,COALESCE(info_total_interesados.nombre, 'INDETERMINADO') AS interesado
  ,COALESCE(info_total_interesados.agrupacion_interesado, 'INDETERMINADO') AS tipo_interesado
  ,round(st_length(colindantes.geom)::numeric,2) distancia
  ,(select array_to_string( array_agg(puntos_ordenados.id || ': N=' || round(st_y(puntos_ordenados.geom)::numeric,2) || ' metros (m.), E=' || round(st_x(puntos_ordenados.geom)::numeric,2) || ' metros (m.)'), '; ') from puntos_ordenados WHERE st_intersects(colindantes.geom,puntos_ordenados.geom) and puntos_ordenados.id not in (desde, hasta) ) as nodos
  ,degrees(ST_Azimuth(st_startpoint(geom),ST_PointN(geom,2)))
  ,CASE WHEN degrees(ST_Azimuth(st_startpoint(geom),ST_PointN(geom,2))) between 360-(select tolerancia_sentidos from parametros) and 360 or degrees(ST_Azimuth(st_startpoint(geom),ST_PointN(geom,2))) between 0 and (select tolerancia_sentidos from parametros) THEN 'norte'
	  WHEN degrees(ST_Azimuth(st_startpoint(geom),ST_PointN(geom,2))) between (select tolerancia_sentidos from parametros) and 90-(select tolerancia_sentidos from parametros) THEN 'noreste'
	  WHEN degrees(ST_Azimuth(st_startpoint(geom),ST_PointN(geom,2))) between 90-(select tolerancia_sentidos from parametros) and 90+(select tolerancia_sentidos from parametros) THEN 'este'
	  WHEN degrees(ST_Azimuth(st_startpoint(geom),ST_PointN(geom,2))) between 90+(select tolerancia_sentidos from parametros) and 180-(select tolerancia_sentidos from parametros) THEN 'sureste'
	  WHEN degrees(ST_Azimuth(st_startpoint(geom),ST_PointN(geom,2))) between 180-(select tolerancia_sentidos from parametros) and 180+(select tolerancia_sentidos from parametros) THEN 'sur'
	  WHEN degrees(ST_Azimuth(st_startpoint(geom),ST_PointN(geom,2))) between 180+(select tolerancia_sentidos from parametros) and 270-(select tolerancia_sentidos from parametros) THEN 'suroeste'
	  WHEN degrees(ST_Azimuth(st_startpoint(geom),ST_PointN(geom,2))) between 270-(select tolerancia_sentidos from parametros) and 270+(select tolerancia_sentidos from parametros) THEN 'oeste'
	  WHEN degrees(ST_Azimuth(st_startpoint(geom),ST_PointN(geom,2))) between 270+(select tolerancia_sentidos from parametros) and 360-(select tolerancia_sentidos from parametros) THEN 'noroeste'
  END as sentido
  ,(select count(*) from colindantes) as total_linderos
 from colindantes left join info_total_interesados on colindantes.t_id = info_total_interesados.t_id_colindante
 where ubicacion = '3_Sur']]>
	</queryString>
	<field name="id" class="java.lang.Long"/>
	<field name="desde" class="java.lang.Long"/>
	<field name="hasta" class="java.lang.Long"/>
	<field name="ubicacion" class="java.lang.String"/>
	<field name="xi" class="java.math.BigDecimal"/>
	<field name="yi" class="java.math.BigDecimal"/>
	<field name="xf" class="java.math.BigDecimal"/>
	<field name="yf" class="java.math.BigDecimal"/>
	<field name="interesado" class="java.lang.String"/>
	<field name="tipo_interesado" class="java.lang.String"/>
	<field name="distancia" class="java.math.BigDecimal"/>
	<field name="nodos" class="java.lang.String"/>
	<field name="degrees" class="java.lang.Double"/>
	<field name="sentido" class="java.lang.String"/>
	<field name="total_linderos" class="java.lang.Long"/>
	<detail>
		<band height="23" splitType="Stretch">
			<property name="com.jaspersoft.studio.layout" value="com.jaspersoft.studio.editor.layout.FreeLayout"/>
			<textField isStretchWithOverflow="true" pattern="" isBlankWhenNull="true">
				<reportElement stretchType="RelativeToBandHeight" x="20" y="1" width="520" height="19" isPrintWhenDetailOverflows="true" uuid="e9c4fcf3-43da-4f4c-b8f9-7ef03c16a6d9">
					<property name="com.jaspersoft.studio.unit.height" value="pixel"/>
				</reportElement>
				<box bottomPadding="10">
					<topPen lineWidth="0.0" lineStyle="Solid" lineColor="#000000"/>
					<leftPen lineWidth="0.0" lineStyle="Solid" lineColor="#000000"/>
					<bottomPen lineWidth="0.0" lineStyle="Solid" lineColor="#000000"/>
					<rightPen lineWidth="0.0" lineStyle="Solid" lineColor="#000000"/>
				</box>
				<textElement textAlignment="Justified" verticalAlignment="Middle" markup="html">
					<font size="9"/>
					<paragraph lineSpacing="Single" lineSpacingSize="2.0" firstLineIndent="20" leftIndent="5" rightIndent="5"/>
				</textElement>
				<textFieldExpression><![CDATA["<b>LINDERO " + $F{id}+ ":</b> Partiendo del punto " + $F{desde} + " con coordenadas N=" + $F{yi} + " metros (m.), E=" + $F{xi} + " metros (m.)" + ($F{nodos} != null ? " en línea quebrada" :" en línea recta") + " y en sentido " + $F{sentido} +  ($F{nodos} != null ? " pasando por los puntos y coordenadas " + $F{nodos} + ", con una distancia acumulada de " :" en distancia de ") + $F{distancia} + " metros (m.) hasta el punto " + $F{hasta} + " con coordenadas N=" + $F{yf} + " metros (m.), E="  + $F{xf} + " metros (m.)" +($V{REPORT_COUNT}.equals($F{total_linderos}.intValue()) ? ", con el cual cierra el polígono," : ",")  + " colindando con "  + ($F{tipo_interesado}.equals("agrupacion")? "la agrupación conformada por "+ $F{interesado} +" y otros": $F{interesado})  +"."]]></textFieldExpression>
			</textField>
		</band>
	</detail>
</jasperReport>
